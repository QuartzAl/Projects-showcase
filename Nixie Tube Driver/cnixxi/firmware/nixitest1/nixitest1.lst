
nixitest1.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault")));
void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init")));

void InterruptVectorDefault()
{
	asm volatile( "\n\
   0:	58a0006f          	j	58a <handle_reset>
   4:	0000                	unimp
   6:	0000                	unimp
   8:	0602                	c.slli64	a2
   a:	0000                	unimp
   c:	0600                	addi	s0,sp,768
	...
  2e:	0000                	unimp
  30:	0600                	addi	s0,sp,768
  32:	0000                	unimp
  34:	0000                	unimp
  36:	0000                	unimp
  38:	0600                	addi	s0,sp,768
  3a:	0000                	unimp
  3c:	0000                	unimp
  3e:	0000                	unimp
  40:	0600                	addi	s0,sp,768
  42:	0000                	unimp
  44:	0600                	addi	s0,sp,768
  46:	0000                	unimp
  48:	0600                	addi	s0,sp,768
  4a:	0000                	unimp
  4c:	0600                	addi	s0,sp,768
  4e:	0000                	unimp
  50:	0600                	addi	s0,sp,768
  52:	0000                	unimp
  54:	0600                	addi	s0,sp,768
  56:	0000                	unimp
  58:	0600                	addi	s0,sp,768
  5a:	0000                	unimp
  5c:	0600                	addi	s0,sp,768
  5e:	0000                	unimp
  60:	0600                	addi	s0,sp,768
  62:	0000                	unimp
  64:	0600                	addi	s0,sp,768
  66:	0000                	unimp
  68:	0600                	addi	s0,sp,768
  6a:	0000                	unimp
  6c:	0600                	addi	s0,sp,768
  6e:	0000                	unimp
  70:	0600                	addi	s0,sp,768
  72:	0000                	unimp
  74:	0008                	0x8
  76:	2000                	fld	fs0,0(s0)
  78:	0622                	slli	a2,a2,0x8
  7a:	0000                	unimp
  7c:	07c2                	slli	a5,a5,0x10
  7e:	0000                	unimp
  80:	0600                	addi	s0,sp,768
  82:	0000                	unimp
  84:	0600                	addi	s0,sp,768
  86:	0000                	unimp
  88:	0600                	addi	s0,sp,768
  8a:	0000                	unimp
  8c:	0600                	addi	s0,sp,768
  8e:	0000                	unimp
  90:	0600                	addi	s0,sp,768
  92:	0000                	unimp
  94:	0600                	addi	s0,sp,768
  96:	0000                	unimp
  98:	0600                	addi	s0,sp,768
  9a:	0000                	unimp
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <SetupDebugPrintf>:
}

void SetupDebugPrintf()
{
	// Clear out the sending flag.
	*DMDATA1 = 0x0;
  a0:	e00007b7          	lui	a5,0xe0000
  a4:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
	*DMDATA0 = 0x80;
  a8:	08000713          	li	a4,128
  ac:	0ee7aa23          	sw	a4,244(a5)
}
  b0:	8082                	ret

000000b2 <GenOnMask>:

uint16_t GenOnMask( int segmenton )
{
	// Produce a bit mask with only one bit on. To indicate the IO to turn on
	// to light up a given segment.  If segmenton == 0, then all IO are off.
	if( segmenton > 0 )
  b2:	c921                	beqz	a0,102 <GenOnMask+0x50>
	{
		segmenton--;
  b4:	fff50793          	addi	a5,a0,-1
		if ( segmenton == 0 )
			return (1<<7)<<8;
  b8:	6521                	lui	a0,0x8
		if ( segmenton == 0 )
  ba:	cba9                	beqz	a5,10c <GenOnMask+0x5a>
		else if( segmenton == 1 )
  bc:	4705                	li	a4,1
			return (1<<0)<<8;
  be:	10000513          	li	a0,256
		else if( segmenton == 1 )
  c2:	04e78563          	beq	a5,a4,10c <GenOnMask+0x5a>
		else if( segmenton == 2 )
  c6:	4689                	li	a3,2
			return 1<<0;
  c8:	4505                	li	a0,1
		else if( segmenton == 2 )
  ca:	04d78163          	beq	a5,a3,10c <GenOnMask+0x5a>
		else if( segmenton < 8 )
  ce:	469d                	li	a3,7
  d0:	00f6c763          	blt	a3,a5,de <GenOnMask+0x2c>
			return 1<<segmenton;
  d4:	00f71533          	sll	a0,a4,a5
  d8:	0542                	slli	a0,a0,0x10
  da:	8141                	srli	a0,a0,0x10
  dc:	8082                	ret
		else if( segmenton == 8 )
  de:	4721                	li	a4,8
			return (1<<2)<<8;
  e0:	40000513          	li	a0,1024
		else if( segmenton == 8 )
  e4:	02e78463          	beq	a5,a4,10c <GenOnMask+0x5a>
		else if( segmenton == 9 )
  e8:	4725                	li	a4,9
  ea:	00e78e63          	beq	a5,a4,106 <GenOnMask+0x54>
			return (1<<3)<<8;
		else if( segmenton == 10 )
  ee:	4729                	li	a4,10
			return (1<<5)<<8; // 5 is the left comma
  f0:	6509                	lui	a0,0x2
		else if( segmenton == 10 )
  f2:	00e78d63          	beq	a5,a4,10c <GenOnMask+0x5a>
		else if( segmenton == 11 )
  f6:	472d                	li	a4,11
			return (1<<6)<<8; // 6 is the right comma
	}
	return 0;
  f8:	4501                	li	a0,0
		else if( segmenton == 11 )
  fa:	00e79963          	bne	a5,a4,10c <GenOnMask+0x5a>
			return (1<<6)<<8; // 6 is the right comma
  fe:	6511                	lui	a0,0x4
 100:	8082                	ret
	return 0;
 102:	4501                	li	a0,0
 104:	8082                	ret
			return (1<<3)<<8;
 106:	6505                	lui	a0,0x1
 108:	80050513          	addi	a0,a0,-2048 # 800 <I2C1_ER_IRQHandler+0x3e>
}
 10c:	8082                	ret

0000010e <onWrite>:



void onWrite( uint8_t reg, uint8_t length )
{
	if (reg > 19){
 10e:	474d                	li	a4,19
 110:	00a77c63          	bgeu	a4,a0,128 <onWrite+0x1a>
		int feedback = reg - 20;
		if( feedback > ABSOLUTE_MAX_ADC_SET )
			feedback = ABSOLUTE_MAX_ADC_SET;
		target_feedback = feedback;
 114:	1531                	addi	a0,a0,-20
 116:	0be00793          	li	a5,190
 11a:	00a7d463          	bge	a5,a0,122 <onWrite+0x14>
 11e:	0be00513          	li	a0,190
 122:	92a1a023          	sw	a0,-1760(gp) # 20000120 <target_feedback>
 126:	8082                	ret
{
 128:	1151                	addi	sp,sp,-12
 12a:	c406                	sw	ra,8(sp)
	} else {
		ApplyOnMask( GenOnMask( reg ) );
 12c:	3759                	jal	b2 <GenOnMask>
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 12e:	00855793          	srli	a5,a0,0x8
 132:	40011737          	lui	a4,0x40011
 136:	07c2                	slli	a5,a5,0x10
	}
}
 138:	40a2                	lw	ra,8(sp)
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 13a:	83c1                	srli	a5,a5,0x10
 13c:	40070693          	addi	a3,a4,1024 # 40011400 <__global_pointer$+0x20010c00>
 140:	c6dc                	sw	a5,12(a3)
	GPIOC->OUTDR = onmask & 0xff;
 142:	0ff57513          	andi	a0,a0,255
 146:	c748                	sw	a0,12(a4)
}
 148:	0131                	addi	sp,sp,12
 14a:	8082                	ret

0000014c <main>:



int main()
{
 14c:	fc810113          	addi	sp,sp,-56
	IWDG->CTLR = 0x5555; // Go into watchdog setup mode.
 150:	6795                	lui	a5,0x5
 152:	55578793          	addi	a5,a5,1365 # 5555 <nixitest1.c.1638a390+0x332e>
{
 156:	da06                	sw	ra,52(sp)
 158:	d822                	sw	s0,48(sp)
 15a:	d626                	sw	s1,44(sp)
	IWDG->CTLR = 0x5555; // Go into watchdog setup mode.
 15c:	40003737          	lui	a4,0x40003
 160:	c31c                	sw	a5,0(a4)
	while( IWDG->STATR & IWDG_PVU ); // Wait for PSCR to become recepitve.
 162:	400037b7          	lui	a5,0x40003
 166:	47d8                	lw	a4,12(a5)
 168:	8b05                	andi	a4,a4,1
 16a:	ff75                	bnez	a4,166 <main+0x1a>
	IWDG->PSCR = 1;      // div LSI by 8 (4 seems unreliable)
 16c:	4685                	li	a3,1
	IWDG->RLDR = 0xFFF;  // reload watchdog, not important don't need to check.
 16e:	6705                	lui	a4,0x1
	IWDG->PSCR = 1;      // div LSI by 8 (4 seems unreliable)
 170:	c3d4                	sw	a3,4(a5)
	IWDG->RLDR = 0xFFF;  // reload watchdog, not important don't need to check.
 172:	177d                	addi	a4,a4,-1
 174:	c798                	sw	a4,8(a5)
	IWDG->CTLR = 0xCCCC; // commit registers.
 176:	6735                	lui	a4,0xd
 178:	ccc70713          	addi	a4,a4,-820 # cccc <nixitest1.c.1638a390+0xaaa5>
 17c:	c398                	sw	a4,0(a5)
	IWDG->CTLR = 0xAAAA;
 17e:	672d                	lui	a4,0xb
 180:	aaa70713          	addi	a4,a4,-1366 # aaaa <nixitest1.c.1638a390+0x8883>
 184:	c398                	sw	a4,0(a5)
	RCC->CTLR  = RCC_HSION | RCC_PLLON; 				// Use HSI, but enable PLL.
 186:	01000737          	lui	a4,0x1000
 18a:	400217b7          	lui	a5,0x40021
 18e:	0705                	addi	a4,a4,1
 190:	c398                	sw	a4,0(a5)
	RCC->CFGR0 = RCC_HPRE_DIV1 | RCC_PLLSRC_HSI_Mul2;	// PLLCLK = HSI * 2 = 48 MHz; HCLK = SYSCLK = APB1
 192:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;				// 1 Cycle Latency
 196:	40022737          	lui	a4,0x40022
 19a:	c314                	sw	a3,0(a4)
	RCC->INTR  = 0x009F0000;                            // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 19c:	009f0737          	lui	a4,0x9f0
 1a0:	c798                	sw	a4,8(a5)
	while((RCC->CTLR & RCC_PLLRDY) == 0);														// Wait till PLL is ready
 1a2:	020006b7          	lui	a3,0x2000
 1a6:	40021737          	lui	a4,0x40021
 1aa:	431c                	lw	a5,0(a4)
 1ac:	8ff5                	and	a5,a5,a3
 1ae:	dff5                	beqz	a5,1aa <main+0x5e>
	RCC->CFGR0 = ( RCC->CFGR0 & ((uint32_t)~(RCC_SW))) | (uint32_t)RCC_SW_PLL;					// Select PLL as system clock source
 1b0:	435c                	lw	a5,4(a4)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08);									// Wait till PLL is used as system clock source
 1b2:	40021437          	lui	s0,0x40021
	RCC->CFGR0 = ( RCC->CFGR0 & ((uint32_t)~(RCC_SW))) | (uint32_t)RCC_SW_PLL;					// Select PLL as system clock source
 1b6:	9bf1                	andi	a5,a5,-4
 1b8:	0027e793          	ori	a5,a5,2
 1bc:	c35c                	sw	a5,4(a4)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08);									// Wait till PLL is used as system clock source
 1be:	4721                	li	a4,8
 1c0:	405c                	lw	a5,4(s0)
 1c2:	8bb1                	andi	a5,a5,12
 1c4:	fee79ee3          	bne	a5,a4,1c0 <main+0x74>

	// Use internall RC oscillator + 2xPLL to generate 48 MHz system clock.
	SystemInit48HSI();

	// For the ability to printf() if we want.
	SetupDebugPrintf();
 1c8:	3de1                	jal	a0 <SetupDebugPrintf>
	IWDG->CTLR = 0xAAAA;
 1ca:	67ad                	lui	a5,0xb
 1cc:	40003737          	lui	a4,0x40003
 1d0:	aaa78793          	addi	a5,a5,-1366 # aaaa <nixitest1.c.1638a390+0x8883>
 1d4:	c31c                	sw	a5,0(a4)

	// Pet watchdog for the rest of startup.
	WatchdogPet();

	// Enable Peripherals
	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC |
 1d6:	4c1c                	lw	a5,24(s0)
 1d8:	6705                	lui	a4,0x1
 1da:	a3570713          	addi	a4,a4,-1483 # a35 <_data_lma+0x1f5>
 1de:	8fd9                	or	a5,a5,a4
 1e0:	cc1c                	sw	a5,24(s0)
		RCC_APB2Periph_GPIOA | RCC_APB2Periph_TIM1 | RCC_APB2Periph_ADC1 |
		RCC_APB2Periph_AFIO;

	RCC->APB1PCENR = RCC_APB1Periph_TIM2;
 1e2:	4785                	li	a5,1
 1e4:	cc5c                	sw	a5,28(s0)
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 1e6:	400117b7          	lui	a5,0x40011
 1ea:	40078713          	addi	a4,a5,1024 # 40011400 <__global_pointer$+0x20010c00>
 1ee:	00072623          	sw	zero,12(a4)

	// I'm paranoid - let's make sure all tube cathodes are high-Z.
	ApplyOnMask( 0 );

	GPIOD->CFGLR = 
 1f2:	111016b7          	lui	a3,0x11101
	GPIOC->OUTDR = onmask & 0xff;
 1f6:	0007a623          	sw	zero,12(a5)
	GPIOD->CFGLR = 
 1fa:	15168693          	addi	a3,a3,337 # 11101151 <nixitest1.c.1638a390+0x110fef2a>
 1fe:	c314                	sw	a3,0(a4)
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*3) | // DIG_9
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*2) | // DIG_8
		(GPIO_Speed_10MHz | GPIO_CNF_IN_FLOATING)<<(4*1) | // PGM Floats.
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*0);  // DIG_1

	GPIOC->CFGLR = 
 200:	111126b7          	lui	a3,0x11112
 204:	dd168693          	addi	a3,a3,-559 # 11111dd1 <nixitest1.c.1638a390+0x1110fbaa>
 208:	c394                	sw	a3,0(a5)
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*5) | // DIG_5
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*6) | // DIG_6
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*7);  // DIG_7


	GPIOA->CFGLR =
 20a:	80078793          	addi	a5,a5,-2048
 20e:	0b000693          	li	a3,176
 212:	c394                	sw	a3,0(a5)
	GPIOD->CFGLR &= ~(0xf<<(4*4));	// CNF = 00: Analog, MODE = 00: Input
 214:	431c                	lw	a5,0(a4)
 216:	fff106b7          	lui	a3,0xfff10
 21a:	16fd                	addi	a3,a3,-1
 21c:	8ff5                	and	a5,a5,a3
 21e:	c31c                	sw	a5,0(a4)
	RCC->APB2PRSTR |= RCC_APB2Periph_ADC1;
 220:	445c                	lw	a5,12(s0)
	RCC->CFGR0 &= ~RCC_ADCPRE;  // Clear out the bis in case they were set
 222:	7751                	lui	a4,0xffff4
 224:	177d                	addi	a4,a4,-1
	RCC->APB2PRSTR |= RCC_APB2Periph_ADC1;
 226:	2007e793          	ori	a5,a5,512
 22a:	c45c                	sw	a5,12(s0)
	RCC->APB2PRSTR &= ~RCC_APB2Periph_ADC1;
 22c:	445c                	lw	a5,12(s0)
	while(ADC1->CTLR2 & ADC_RSTCAL);
 22e:	400126b7          	lui	a3,0x40012
	RCC->APB2PRSTR &= ~RCC_APB2Periph_ADC1;
 232:	dff7f793          	andi	a5,a5,-513
 236:	c45c                	sw	a5,12(s0)
	RCC->CFGR0 &= ~RCC_ADCPRE;  // Clear out the bis in case they were set
 238:	405c                	lw	a5,4(s0)
 23a:	8ff9                	and	a5,a5,a4
 23c:	c05c                	sw	a5,4(s0)
	RCC->CFGR0 |= RCC_ADCPRE_DIV4;	// set it to 010xx for /4.
 23e:	405c                	lw	a5,4(s0)
 240:	6711                	lui	a4,0x4
 242:	8fd9                	or	a5,a5,a4
 244:	c05c                	sw	a5,4(s0)
	ADC1->RSQR1 = 0;
 246:	400127b7          	lui	a5,0x40012
 24a:	40078793          	addi	a5,a5,1024 # 40012400 <__global_pointer$+0x20011c00>
 24e:	0207a623          	sw	zero,44(a5)
	ADC1->RSQR2 = 0;
 252:	0207a823          	sw	zero,48(a5)
	ADC1->RSQR3 = 7;	// 0-9 for 8 ext inputs and two internals
 256:	471d                	li	a4,7
 258:	dbd8                	sw	a4,52(a5)
	ADC1->ISQR = (8<<15) | (0<<20);
 25a:	00040737          	lui	a4,0x40
 25e:	df98                	sw	a4,56(a5)
	ADC1->SAMPTR2 = (3<<(3*7)) | (3<<(3*8)); 
 260:	03600737          	lui	a4,0x3600
 264:	cb98                	sw	a4,16(a5)
	ADC1->CTLR2 = ADC_ADON | ADC_JEXTTRIG | ADC_JEXTSEL | ADC_EXTTRIG; 
 266:	0010f737          	lui	a4,0x10f
 26a:	0705                	addi	a4,a4,1
 26c:	c798                	sw	a4,8(a5)
	ADC1->CTLR2 |= ADC_RSTCAL;
 26e:	4798                	lw	a4,8(a5)
 270:	00876713          	ori	a4,a4,8
 274:	c798                	sw	a4,8(a5)
	while(ADC1->CTLR2 & ADC_RSTCAL);
 276:	40068793          	addi	a5,a3,1024 # 40012400 <__global_pointer$+0x20011c00>
 27a:	4798                	lw	a4,8(a5)
 27c:	8b21                	andi	a4,a4,8
 27e:	ff65                	bnez	a4,276 <main+0x12a>
	ADC1->CTLR2 |= ADC_CAL;
 280:	4798                	lw	a4,8(a5)
	while(ADC1->CTLR2 & ADC_CAL);
 282:	400126b7          	lui	a3,0x40012
	ADC1->CTLR2 |= ADC_CAL;
 286:	00476713          	ori	a4,a4,4
 28a:	c798                	sw	a4,8(a5)
	while(ADC1->CTLR2 & ADC_CAL);
 28c:	40068713          	addi	a4,a3,1024 # 40012400 <__global_pointer$+0x20011c00>
 290:	471c                	lw	a5,8(a4)
 292:	8b91                	andi	a5,a5,4
 294:	ffe5                	bnez	a5,28c <main+0x140>
	ADC1->CTLR1 = ADC_JEOCIE | ADC_JDISCEN | ADC_SCAN | ADC_JAUTO;
 296:	6605                	lui	a2,0x1
 *
 * @return  none
 */
RV_STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 298:	e000e337          	lui	t1,0xe000e
 29c:	200007b7          	lui	a5,0x20000
 2a0:	10f32023          	sw	a5,256(t1) # e000e100 <__global_pointer$+0xc000d900>
 2a4:	58060793          	addi	a5,a2,1408 # 1580 <ch32v003fun.c.d5aaab49+0x1ec>
 2a8:	c35c                	sw	a5,4(a4)
	RCC->APB2PRSTR |= RCC_APB2Periph_TIM1;
 2aa:	40021437          	lui	s0,0x40021
 2ae:	445c                	lw	a5,12(s0)
 2b0:	80060713          	addi	a4,a2,-2048
	TIM1->PSC = 0x0000;  // Prescalar to 0x0000 (so, 48MHz base clock)
 2b4:	40013537          	lui	a0,0x40013
	RCC->APB2PRSTR |= RCC_APB2Periph_TIM1;
 2b8:	8fd9                	or	a5,a5,a4
 2ba:	c45c                	sw	a5,12(s0)
	RCC->APB2PRSTR &= ~RCC_APB2Periph_TIM1;
 2bc:	445c                	lw	a5,12(s0)
 2be:	777d                	lui	a4,0xfffff
 2c0:	7ff70713          	addi	a4,a4,2047 # fffff7ff <__global_pointer$+0xdfffefff>
 2c4:	8ff9                	and	a5,a5,a4
 2c6:	c45c                	sw	a5,12(s0)
	TIM1->PSC = 0x0000;  // Prescalar to 0x0000 (so, 48MHz base clock)
 2c8:	c2051423          	sh	zero,-984(a0) # 40012c28 <__global_pointer$+0x20012428>
	TIM1->ATRLR = PWM_PERIOD;
 2cc:	08c00713          	li	a4,140
 2d0:	c2e51623          	sh	a4,-980(a0)
	TIM1->CCER = TIM_CC2E | TIM_CC2NP;  // CH2 is control for FET.
 2d4:	09000713          	li	a4,144
 2d8:	c2e51023          	sh	a4,-992(a0)
	TIM1->CHCTLR1 = TIM_OC2M_2 | TIM_OC2M_1;
 2dc:	6599                	lui	a1,0x6
 2de:	c0b51c23          	sh	a1,-1000(a0)
	TIM1->PSC = 0x0000;  // Prescalar to 0x0000 (so, 48MHz base clock)
 2e2:	c0050793          	addi	a5,a0,-1024
	TIM1->CH2CVR = 0;  // Actual duty cycle (Off to begin with)
 2e6:	0207ac23          	sw	zero,56(a5) # 20000038 <ADC1_IRQHandler+0x30>
	TIM1->CTLR2 = TIM_MMS_1;
 2ea:	02000293          	li	t0,32
 2ee:	c0551223          	sh	t0,-1020(a0)
	TIM1->BDTR = TIM_MOE;
 2f2:	76e1                	lui	a3,0xffff8
 2f4:	c4d51223          	sh	a3,-956(a0)
	TIM1->CTLR1 = TIM_CEN;
 2f8:	4705                	li	a4,1
 2fa:	c0e51023          	sh	a4,-1024(a0)
	RCC->APB1PRSTR |= RCC_APB1Periph_TIM2;
 2fe:	481c                	lw	a5,16(s0)
	TIM2->PSC = 0x0020;
 300:	400004b7          	lui	s1,0x40000
	RCC->APB1PRSTR |= RCC_APB1Periph_TIM2;
 304:	0017e793          	ori	a5,a5,1
 308:	c81c                	sw	a5,16(s0)
	RCC->APB1PRSTR &= ~RCC_APB1Periph_TIM2;
 30a:	481c                	lw	a5,16(s0)
	// 	ApplyOnMask( GenOnMask( i ) );
	// 	Delay_Ms(250);
	// }
	ApplyOnMask( 0 );

	volatile uint8_t i2c_registers[32] = { 0x00 };
 30c:	0808                	addi	a0,sp,16
	RCC->APB1PRSTR &= ~RCC_APB1Periph_TIM2;
 30e:	9bf9                	andi	a5,a5,-2
 310:	c81c                	sw	a5,16(s0)
	TIM2->PSC = 0x0020;
 312:	02549423          	sh	t0,40(s1) # 40000028 <__global_pointer$+0x1ffff828>
	TIM2->ATRLR = 255;				// 0..255 (So we can be 100% on)
 316:	0ff00793          	li	a5,255
 31a:	02f49623          	sh	a5,44(s1)
	TIM2->CHCTLR2 = TIM_OC4M_2 | TIM_OC4M_1;
 31e:	00b49e23          	sh	a1,28(s1)
	TIM2->CCER = TIM_CC4E;
 322:	02c49023          	sh	a2,32(s1)
	TIM2->CH4CVR = 0;  			// Actual duty cycle (Off to begin with)
 326:	0404a023          	sw	zero,64(s1)
	TIM2->BDTR = TIM_MOE;
 32a:	04d49223          	sh	a3,68(s1)
	TIM2->CTLR1 = TIM_CEN;
 32e:	00e49023          	sh	a4,0(s1)
	*DMDATA0 = 0;
 332:	e00007b7          	lui	a5,0xe0000
 336:	0e07aa23          	sw	zero,244(a5) # e00000f4 <__global_pointer$+0xbffff8f4>
	target_feedback = 170;
 33a:	0aa00793          	li	a5,170
 33e:	92f1a023          	sw	a5,-1760(gp) # 20000120 <target_feedback>
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 342:	400117b7          	lui	a5,0x40011
 346:	40078613          	addi	a2,a5,1024 # 40011400 <__global_pointer$+0x20010c00>
 34a:	00062623          	sw	zero,12(a2)
	GPIOC->OUTDR = onmask & 0xff;
 34e:	0007a623          	sw	zero,12(a5)
	volatile uint8_t i2c_registers[32] = { 0x00 };
 352:	4671                	li	a2,28
 354:	4581                	li	a1,0
 356:	c602                	sw	zero,12(sp)
 358:	2c65                	jal	610 <memset>
    bool writing;
    bool address2matched;
} i2c_slave_state;

void SetupI2CSlave(uint8_t address, volatile uint8_t* registers, uint8_t size, i2c_write_callback_t write_callback, i2c_read_callback_t read_callback, bool read_only) {
    i2c_slave_state.first_write = 1;
 35a:	92418793          	addi	a5,gp,-1756 # 20000124 <i2c_slave_state>
    i2c_slave_state.offset = 0;
    i2c_slave_state.position = 0;
    i2c_slave_state.registers1 = registers;
 35e:	0074                	addi	a3,sp,12
 360:	c3d4                	sw	a3,4(a5)
    i2c_slave_state.first_write = 1;
 362:	4705                	li	a4,1
    i2c_slave_state.size1 = size;
 364:	02000293          	li	t0,32
    i2c_slave_state.registers2 = NULL;
 368:	0007a623          	sw	zero,12(a5)
    i2c_slave_state.first_write = 1;
 36c:	00e79023          	sh	a4,0(a5)
    i2c_slave_state.position = 0;
 370:	00078123          	sb	zero,2(a5)
    i2c_slave_state.size1 = size;
 374:	00578423          	sb	t0,8(a5)
    i2c_slave_state.size2 = 0;
 378:	00078823          	sb	zero,16(a5)
    i2c_slave_state.write_callback1 = write_callback;
 37c:	10e00613          	li	a2,270
 380:	cbd0                	sw	a2,20(a5)
    i2c_slave_state.write_callback2 = NULL;
    i2c_slave_state.read_callback2 = NULL;
    i2c_slave_state.read_only2 = false;

    // Enable I2C1
    RCC->APB1PCENR |= RCC_APB1Periph_I2C1;
 382:	4c50                	lw	a2,28(s0)
 384:	002005b7          	lui	a1,0x200
    i2c_slave_state.read_only1 = read_only;
 388:	00e78e23          	sb	a4,28(a5)
    i2c_slave_state.read_callback1 = read_callback;
 38c:	0007ac23          	sw	zero,24(a5)
    i2c_slave_state.write_callback2 = NULL;
 390:	0207a023          	sw	zero,32(a5)
    i2c_slave_state.read_callback2 = NULL;
 394:	0207a223          	sw	zero,36(a5)
    i2c_slave_state.read_only2 = false;
 398:	02078423          	sb	zero,40(a5)
    RCC->APB1PCENR |= RCC_APB1Periph_I2C1;
 39c:	8e4d                	or	a2,a2,a1
 39e:	cc50                	sw	a2,28(s0)

    // Reset I2C1 to init all regs
    RCC->APB1PRSTR |= RCC_APB1Periph_I2C1;
 3a0:	481c                	lw	a5,16(s0)
    RCC->APB1PRSTR &= ~RCC_APB1Periph_I2C1;
 3a2:	ffe00637          	lui	a2,0xffe00
 3a6:	167d                	addi	a2,a2,-1
    RCC->APB1PRSTR |= RCC_APB1Periph_I2C1;
 3a8:	8fcd                	or	a5,a5,a1
 3aa:	c81c                	sw	a5,16(s0)
    RCC->APB1PRSTR &= ~RCC_APB1Periph_I2C1;
 3ac:	481c                	lw	a5,16(s0)

    I2C1->CTLR1 |= I2C_CTLR1_SWRST;
 3ae:	6521                	lui	a0,0x8
 3b0:	e000e337          	lui	t1,0xe000e
    RCC->APB1PRSTR &= ~RCC_APB1Periph_I2C1;
 3b4:	8ff1                	and	a5,a5,a2
 3b6:	c81c                	sw	a5,16(s0)
    I2C1->CTLR1 |= I2C_CTLR1_SWRST;
 3b8:	400057b7          	lui	a5,0x40005
 3bc:	4007d583          	lhu	a1,1024(a5) # 40005400 <__global_pointer$+0x20004c00>
    NVIC_EnableIRQ(I2C1_ER_IRQn); // Error interrupt
    NVIC_SetPriority(I2C1_ER_IRQn, 2 << 4);

    // Set clock configuration
    uint32_t clockrate = 1000000; // I2C Bus clock rate, must be lower than the logic clock rate
    I2C1->CKCFGR = ((FUNCONF_SYSTEM_CORE_CLOCK/(3*clockrate))&I2C_CKCFGR_CCR) | I2C_CKCFGR_FS; // Fast mode 33% duty cycle
 3c0:	76e1                	lui	a3,0xffff8
 3c2:	06c1                	addi	a3,a3,16
    I2C1->CTLR1 |= I2C_CTLR1_SWRST;
 3c4:	05c2                	slli	a1,a1,0x10
 3c6:	81c1                	srli	a1,a1,0x10
 3c8:	8dc9                	or	a1,a1,a0
 3ca:	40b79023          	sh	a1,1024(a5)
    I2C1->CTLR1 &= ~I2C_CTLR1_SWRST;
 3ce:	4007d583          	lhu	a1,1024(a5)
 3d2:	05c6                	slli	a1,a1,0x11
 3d4:	81c5                	srli	a1,a1,0x11
 3d6:	40b79023          	sh	a1,1024(a5)
    I2C1->CTLR2 |= (FUNCONF_SYSTEM_CORE_CLOCK/prerate) & I2C_CTLR2_FREQ;
 3da:	4047d583          	lhu	a1,1028(a5)
 3de:	05c2                	slli	a1,a1,0x10
 3e0:	81c1                	srli	a1,a1,0x10
 3e2:	0185e593          	ori	a1,a1,24
 3e6:	40b79223          	sh	a1,1028(a5)
    I2C1->CTLR2 |= I2C_CTLR2_ITBUFEN | I2C_CTLR2_ITEVTEN | I2C_CTLR2_ITERREN;
 3ea:	4047d583          	lhu	a1,1028(a5)
 3ee:	05c2                	slli	a1,a1,0x10
 3f0:	81c1                	srli	a1,a1,0x10
 3f2:	7005e593          	ori	a1,a1,1792
 3f6:	40b79223          	sh	a1,1028(a5)
 3fa:	10932023          	sw	s1,256(t1) # e000e100 <__global_pointer$+0xc000d900>
 *
 * @return  none
 */
RV_STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint8_t priority)
{
  NVIC->IPRIOR[(uint32_t)(IRQn)] = priority;
 3fe:	40530f23          	sb	t0,1054(t1)
  NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 402:	800005b7          	lui	a1,0x80000
 406:	10b32023          	sw	a1,256(t1)
  NVIC->IPRIOR[(uint32_t)(IRQn)] = priority;
 40a:	40530fa3          	sb	t0,1055(t1)
    I2C1->CKCFGR = ((FUNCONF_SYSTEM_CORE_CLOCK/(3*clockrate))&I2C_CKCFGR_CCR) | I2C_CKCFGR_FS; // Fast mode 33% duty cycle
 40e:	40d79e23          	sh	a3,1052(a5)
    //I2C1->CKCFGR = ((FUNCONF_SYSTEM_CORE_CLOCK/(25*clockrate))&I2C_CKCFGR_CCR) | I2C_CKCFGR_DUTY | I2C_CKCFGR_FS; // Fast mode 36% duty cycle
    //I2C1->CKCFGR = (FUNCONF_SYSTEM_CORE_CLOCK/(2*clockrate))&I2C_CKCFGR_CCR; // Standard mode good to 100kHz

    // Set I2C address
    I2C1->OADDR1 = address << 1;
 412:	46d1                	li	a3,20
 414:	40d79423          	sh	a3,1032(a5)
    I2C1->OADDR2 = 0;
 418:	40079623          	sh	zero,1036(a5)

    // Enable I2C
    I2C1->CTLR1 |= I2C_CTLR1_PE;
 41c:	4007d683          	lhu	a3,1024(a5)
 420:	06c2                	slli	a3,a3,0x10
 422:	82c1                	srli	a3,a3,0x10
 424:	0016e693          	ori	a3,a3,1
 428:	40d79023          	sh	a3,1024(a5)

    // Acknowledge bytes when they are received
    I2C1->CTLR1 |= I2C_CTLR1_ACK;
 42c:	4007d683          	lhu	a3,1024(a5)
 430:	06c2                	slli	a3,a3,0x10
 432:	82c1                	srli	a3,a3,0x10
 434:	4006e693          	ori	a3,a3,1024
 438:	40d79023          	sh	a3,1024(a5)
	IWDG->CTLR = 0xAAAA;
 43c:	67ad                	lui	a5,0xb
 43e:	400036b7          	lui	a3,0x40003
 442:	aaa78793          	addi	a5,a5,-1366 # aaaa <nixitest1.c.1638a390+0x8883>
 446:	c29c                	sw	a5,0(a3)
	SetupI2CSlave( 0xA, i2c_registers, sizeof( i2c_registers ), onWrite, NULL, 1 );
	WatchdogPet();

	// Cause system timer to run and reload when it hits CMP and HCLK/8.
	// Also, don't stop at comparison value.
	SysTick->CTLR = 1;
 448:	e000f7b7          	lui	a5,0xe000f
 44c:	c398                	sw	a4,0(a5)
 44e:	9041d683          	lhu	a3,-1788(gp) # 20000104 <fade_time0>
 452:	9061d603          	lhu	a2,-1786(gp) # 20000106 <fade_time1>
 456:	9001d703          	lhu	a4,-1792(gp) # 20000100 <fade_disp0>
 45a:	9021d503          	lhu	a0,-1790(gp) # 20000102 <fade_disp1>
 45e:	92018793          	addi	a5,gp,-1760 # 20000120 <target_feedback>
 462:	c23e                	sw	a5,4(sp)
		fade_time1 = -1;
 464:	67c1                	lui	a5,0x10
 466:	17fd                	addi	a5,a5,-1
 468:	c03e                	sw	a5,0(sp)

	// int i = 1;
	while(1)
	{
		uint32_t dmdword = *DMDATA0;
 46a:	e00004b7          	lui	s1,0xe0000
 46e:	0f44a403          	lw	s0,244(s1) # e00000f4 <__global_pointer$+0xbffff8f4>
		if( (dmdword & 0xf0) == 0x40 )
 472:	04000593          	li	a1,64
 476:	0f047313          	andi	t1,s0,240
 47a:	02b31c63          	bne	t1,a1,4b2 <main+0x366>
	int command = dmdword & 0x0f;
 47e:	00f47593          	andi	a1,s0,15
	switch( command )
 482:	430d                	li	t1,3
 484:	0a658e63          	beq	a1,t1,540 <main+0x3f4>
 488:	00c47313          	andi	t1,s0,12
 48c:	06031d63          	bnez	t1,506 <main+0x3ba>
 490:	4305                	li	t1,1
 492:	08658363          	beq	a1,t1,518 <main+0x3cc>
 496:	4309                	li	t1,2
 498:	08658b63          	beq	a1,t1,52e <main+0x3e2>
	*DMDATA0 = ((lastadc>>ADC_IIR) << 12) | ((lastrefvdd>>VDD_IIR) << 22);
 49c:	9101a783          	lw	a5,-1776(gp) # 20000110 <lastadc>
 4a0:	91c1a583          	lw	a1,-1764(gp) # 2000011c <lastrefvdd>
 4a4:	8789                	srai	a5,a5,0x2
 4a6:	8589                	srai	a1,a1,0x2
 4a8:	07b2                	slli	a5,a5,0xc
 4aa:	05da                	slli	a1,a1,0x16
 4ac:	8fcd                	or	a5,a5,a1
 4ae:	0ef4aa23          	sw	a5,244(s1)
	uint32_t fadepos = (SysTick->CNT >> 5) & 0xff;
 4b2:	e000f7b7          	lui	a5,0xe000f
 4b6:	479c                	lw	a5,8(a5)
 4b8:	8395                	srli	a5,a5,0x5
 4ba:	0ff7f793          	andi	a5,a5,255
	fadepos = (fadepos << 4) | ( fadepos >> 4);
 4be:	00479593          	slli	a1,a5,0x4
 4c2:	8391                	srli	a5,a5,0x4
 4c4:	8fcd                	or	a5,a5,a1
	if( fadepos < fade_time0 )
 4c6:	0ff7f793          	andi	a5,a5,255
		return fade_disp0;
 4ca:	85ba                	mv	a1,a4
	if( fadepos < fade_time0 )
 4cc:	00d7e663          	bltu	a5,a3,4d8 <main+0x38c>
		return 0;
 4d0:	4581                	li	a1,0
	else if( fadepos < fade_time1 ) 
 4d2:	00c7f363          	bgeu	a5,a2,4d8 <main+0x38c>
		return fade_disp1;
 4d6:	85aa                	mv	a1,a0
	if( mask != lastmask )
 4d8:	9181a783          	lw	a5,-1768(gp) # 20000118 <lastmask.0>
 4dc:	91818313          	addi	t1,gp,-1768 # 20000118 <lastmask.0>
 4e0:	f8b787e3          	beq	a5,a1,46e <main+0x322>
		if( lastmask )
 4e4:	efbd                	bnez	a5,562 <main+0x416>
		ApplyOnMask( mask );
 4e6:	01059793          	slli	a5,a1,0x10
 4ea:	83c1                	srli	a5,a5,0x10
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 4ec:	0087d413          	srli	s0,a5,0x8
 4f0:	400112b7          	lui	t0,0x40011
 4f4:	4082a623          	sw	s0,1036(t0) # 4001140c <__global_pointer$+0x20010c0c>
	GPIOC->OUTDR = onmask & 0xff;
 4f8:	0ff7f793          	andi	a5,a5,255
 4fc:	00f2a623          	sw	a5,12(t0)
		lastmask = mask;
 500:	00b32023          	sw	a1,0(t1)
 504:	b79d                	j	46a <main+0x31e>
	switch( command )
 506:	4315                	li	t1,5
 508:	f8659ae3          	bne	a1,t1,49c <main+0x350>
		TIM2->CH4CVR = dmdword>>16;
 50c:	01045793          	srli	a5,s0,0x10
 510:	400005b7          	lui	a1,0x40000
 514:	c1bc                	sw	a5,64(a1)
 516:	b759                	j	49c <main+0x350>
		int feedback = dmdword >> 16;
 518:	01045793          	srli	a5,s0,0x10
		target_feedback = feedback;
 51c:	0be00593          	li	a1,190
 520:	00f5d463          	bge	a1,a5,528 <main+0x3dc>
 524:	0be00793          	li	a5,190
 528:	4592                	lw	a1,4(sp)
 52a:	c19c                	sw	a5,0(a1)
		break;
 52c:	bf85                	j	49c <main+0x350>
		int segmenton = (dmdword>>16)&0x0f;
 52e:	01045513          	srli	a0,s0,0x10
		fade_disp0 = GenOnMask(segmenton);
 532:	893d                	andi	a0,a0,15
 534:	3ebd                	jal	b2 <GenOnMask>
		fade_time1 = -1;
 536:	4602                	lw	a2,0(sp)
		fade_disp0 = GenOnMask(segmenton);
 538:	872a                	mv	a4,a0
		fade_disp1 = 0;
 53a:	4501                	li	a0,0
		fade_time0 = -1;
 53c:	86b2                	mv	a3,a2
 53e:	bfb9                	j	49c <main+0x350>
		fade_disp0 = GenOnMask( ( dmdword >> 8 ) & 0xf );
 540:	00845513          	srli	a0,s0,0x8
 544:	893d                	andi	a0,a0,15
 546:	36b5                	jal	b2 <GenOnMask>
 548:	c42a                	sw	a0,8(sp)
		fade_disp1 = GenOnMask( ( dmdword >> 12 ) & 0xf );
 54a:	00c45513          	srli	a0,s0,0xc
 54e:	893d                	andi	a0,a0,15
 550:	368d                	jal	b2 <GenOnMask>
		fade_time0 = ( dmdword >> 16 ) & 0xff;
 552:	01045693          	srli	a3,s0,0x10
 556:	4722                	lw	a4,8(sp)
 558:	0ff6f693          	andi	a3,a3,255
		fade_time1 = ( dmdword >> 24 ) & 0xff;
 55c:	01845613          	srli	a2,s0,0x18
		break;
 560:	bf35                	j	49c <main+0x350>
	GPIOD->OUTDR = (onmask >> 8) & 0xff;
 562:	400117b7          	lui	a5,0x40011
 566:	4007a623          	sw	zero,1036(a5) # 4001140c <__global_pointer$+0x20010c0c>
	GPIOC->OUTDR = onmask & 0xff;
 56a:	0007a623          	sw	zero,12(a5)
#endif

void DelaySysTick( uint32_t n )
{
#ifdef CH32V003
	uint32_t targend = SysTick->CNT + n;
 56e:	e000f7b7          	lui	a5,0xe000f
 572:	0087a283          	lw	t0,8(a5) # e000f008 <__global_pointer$+0xc000e808>
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 576:	e000f3b7          	lui	t2,0xe000f
	uint32_t targend = SysTick->CNT + n;
 57a:	02c9                	addi	t0,t0,18
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 57c:	0083a783          	lw	a5,8(t2) # e000f008 <__global_pointer$+0xc000e808>
 580:	405787b3          	sub	a5,a5,t0
 584:	fe07cce3          	bltz	a5,57c <main+0x430>
 588:	bfb9                	j	4e6 <main+0x39a>

0000058a <handle_reset>:
	asm volatile( "\n\
 58a:	20000197          	auipc	gp,0x20000
 58e:	27618193          	addi	gp,gp,630 # 20000800 <__global_pointer$>
 592:	00018113          	mv	sp,gp
 596:	08000513          	li	a0,128
 59a:	30051073          	csrw	mstatus,a0
 59e:	468d                	li	a3,3
 5a0:	00000517          	auipc	a0,0x0
 5a4:	a6050513          	addi	a0,a0,-1440 # 0 <InterruptVector>
 5a8:	8d55                	or	a0,a0,a3
 5aa:	30551073          	csrw	mtvec,a0
asm volatile(
 5ae:	90018513          	addi	a0,gp,-1792 # 20000100 <fade_disp0>
 5b2:	95018593          	addi	a1,gp,-1712 # 20000150 <_ebss>
 5b6:	4601                	li	a2,0
 5b8:	00b55663          	bge	a0,a1,5c4 <handle_reset+0x3a>
 5bc:	c110                	sw	a2,0(a0)
 5be:	0511                	addi	a0,a0,4
 5c0:	feb54ee3          	blt	a0,a1,5bc <handle_reset+0x32>
 5c4:	00000517          	auipc	a0,0x0
 5c8:	27c50513          	addi	a0,a0,636 # 840 <_data_lma>
 5cc:	20000597          	auipc	a1,0x20000
 5d0:	a3458593          	addi	a1,a1,-1484 # 20000000 <pwm_max_duty>
 5d4:	20000617          	auipc	a2,0x20000
 5d8:	b2c60613          	addi	a2,a2,-1236 # 20000100 <fade_disp0>
 5dc:	00c58863          	beq	a1,a2,5ec <handle_reset+0x62>
 5e0:	4114                	lw	a3,0(a0)
 5e2:	c194                	sw	a3,0(a1)
 5e4:	0511                	addi	a0,a0,4
 5e6:	0591                	addi	a1,a1,4
 5e8:	fec59ae3          	bne	a1,a2,5dc <handle_reset+0x52>
	SysTick->CTLR = 1;
 5ec:	e000f7b7          	lui	a5,0xe000f
 5f0:	4705                	li	a4,1
 5f2:	c398                	sw	a4,0(a5)
asm volatile(
 5f4:	14c00793          	li	a5,332
 5f8:	34179073          	csrw	mepc,a5
 5fc:	30200073          	mret

00000600 <AWU_IRQHandler>:
	asm volatile( "1: j 1b" );
 600:	a001                	j	600 <AWU_IRQHandler>

00000602 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 602:	40021737          	lui	a4,0x40021
 606:	471c                	lw	a5,8(a4)
 608:	008006b7          	lui	a3,0x800
 60c:	8fd5                	or	a5,a5,a3
 60e:	c71c                	sw	a5,8(a4)

00000610 <memset>:
void *memset(void *dest, int c, size_t n) { unsigned char *s = dest; for (; n; n--, s++) *s = c; return dest; }
 610:	962a                	add	a2,a2,a0
 612:	87aa                	mv	a5,a0
 614:	00c79363          	bne	a5,a2,61a <memset+0xa>
 618:	8082                	ret
 61a:	00b78023          	sb	a1,0(a5) # e000f000 <__global_pointer$+0xc000e800>
 61e:	0785                	addi	a5,a5,1
 620:	bfd5                	j	614 <memset+0x4>

00000622 <I2C1_EV_IRQHandler>:
void SetSecondaryI2CSlaveReadOnly(bool read_only) {
    i2c_slave_state.read_only2 = read_only;
}

void I2C1_EV_IRQHandler(void) __attribute__((interrupt));
void I2C1_EV_IRQHandler(void) {
 622:	7179                	addi	sp,sp,-48
 624:	c03e                	sw	a5,0(sp)
    uint16_t STAR1, STAR2 __attribute__((unused));
    STAR1 = I2C1->STAR1;
 626:	400057b7          	lui	a5,0x40005
void I2C1_EV_IRQHandler(void) {
 62a:	c23a                	sw	a4,4(sp)
    STAR1 = I2C1->STAR1;
 62c:	4147d703          	lhu	a4,1044(a5) # 40005414 <__global_pointer$+0x20004c14>
 630:	40078793          	addi	a5,a5,1024
    STAR2 = I2C1->STAR2;
 634:	0187d783          	lhu	a5,24(a5)
void I2C1_EV_IRQHandler(void) {
 638:	cc26                	sw	s1,24(sp)
 63a:	d606                	sw	ra,44(sp)
    STAR1 = I2C1->STAR1;
 63c:	01071493          	slli	s1,a4,0x10
void I2C1_EV_IRQHandler(void) {
 640:	d416                	sw	t0,40(sp)
 642:	d21a                	sw	t1,36(sp)
 644:	d01e                	sw	t2,32(sp)
 646:	ce22                	sw	s0,28(sp)
 648:	ca2a                	sw	a0,20(sp)
 64a:	c82e                	sw	a1,16(sp)
 64c:	c632                	sw	a2,12(sp)
 64e:	c436                	sw	a3,8(sp)

    if (STAR1 & I2C_STAR1_ADDR) { // Start event
 650:	8b09                	andi	a4,a4,2
    STAR1 = I2C1->STAR1;
 652:	80c1                	srli	s1,s1,0x10
    if (STAR1 & I2C_STAR1_ADDR) { // Start event
 654:	c305                	beqz	a4,674 <I2C1_EV_IRQHandler+0x52>
        i2c_slave_state.first_write = 1; // Next write will be the offset
 656:	92418713          	addi	a4,gp,-1756 # 20000124 <i2c_slave_state>
 65a:	4685                	li	a3,1
 65c:	07c2                	slli	a5,a5,0x10
 65e:	83c1                	srli	a5,a5,0x10
 660:	00d70023          	sb	a3,0(a4) # 40021000 <__global_pointer$+0x20020800>
        i2c_slave_state.position = i2c_slave_state.offset; // Reset position
 664:	00174683          	lbu	a3,1(a4)
        i2c_slave_state.address2matched = !!(STAR2 & I2C_STAR2_DUALF);
 668:	839d                	srli	a5,a5,0x7
 66a:	8b85                	andi	a5,a5,1
        i2c_slave_state.position = i2c_slave_state.offset; // Reset position
 66c:	00d70123          	sb	a3,2(a4)
        i2c_slave_state.address2matched = !!(STAR2 & I2C_STAR2_DUALF);
 670:	02f70523          	sb	a5,42(a4)
    }

    if (STAR1 & I2C_STAR1_RXNE) { // Write event
 674:	0404f793          	andi	a5,s1,64
 678:	c795                	beqz	a5,6a4 <I2C1_EV_IRQHandler+0x82>
        if (i2c_slave_state.first_write) { // First byte written, set the offset
 67a:	92418793          	addi	a5,gp,-1756 # 20000124 <i2c_slave_state>
 67e:	0007c703          	lbu	a4,0(a5)
 682:	c379                	beqz	a4,748 <I2C1_EV_IRQHandler+0x126>
            i2c_slave_state.offset = I2C1->DATAR;
 684:	40005737          	lui	a4,0x40005
 688:	40070713          	addi	a4,a4,1024 # 40005400 <__global_pointer$+0x20004c00>
 68c:	01075703          	lhu	a4,16(a4)
            i2c_slave_state.position = i2c_slave_state.offset;
            i2c_slave_state.first_write = 0;
 690:	00078023          	sb	zero,0(a5)
            i2c_slave_state.writing = false;
 694:	020784a3          	sb	zero,41(a5)
            i2c_slave_state.offset = I2C1->DATAR;
 698:	0ff77713          	andi	a4,a4,255
 69c:	00e780a3          	sb	a4,1(a5)
            i2c_slave_state.position = i2c_slave_state.offset;
 6a0:	00e78123          	sb	a4,2(a5)
                }
            }
        }
    }

    if (STAR1 & I2C_STAR1_TXE) { // Read event
 6a4:	0804f793          	andi	a5,s1,128
 6a8:	c7a1                	beqz	a5,6f0 <I2C1_EV_IRQHandler+0xce>
        i2c_slave_state.writing = false;
 6aa:	92418793          	addi	a5,gp,-1756 # 20000124 <i2c_slave_state>
        if (i2c_slave_state.address2matched) {
 6ae:	02a7c703          	lbu	a4,42(a5)
            if (i2c_slave_state.position < i2c_slave_state.size2) {
 6b2:	0027c503          	lbu	a0,2(a5)
        i2c_slave_state.writing = false;
 6b6:	020784a3          	sb	zero,41(a5)
        if (i2c_slave_state.address2matched) {
 6ba:	400057b7          	lui	a5,0x40005
 6be:	40078793          	addi	a5,a5,1024 # 40005400 <__global_pointer$+0x20004c00>
 6c2:	92418413          	addi	s0,gp,-1756 # 20000124 <i2c_slave_state>
 6c6:	cb79                	beqz	a4,79c <I2C1_EV_IRQHandler+0x17a>
            if (i2c_slave_state.position < i2c_slave_state.size2) {
 6c8:	01044703          	lbu	a4,16(s0) # 40021010 <__global_pointer$+0x20020810>
 6cc:	0ee57663          	bgeu	a0,a4,7b8 <I2C1_EV_IRQHandler+0x196>
                I2C1->DATAR = i2c_slave_state.registers2[i2c_slave_state.position];
 6d0:	4458                	lw	a4,12(s0)
 6d2:	972a                	add	a4,a4,a0
 6d4:	00074703          	lbu	a4,0(a4)
 6d8:	0ff77713          	andi	a4,a4,255
 6dc:	00e79823          	sh	a4,16(a5)
                if (i2c_slave_state.read_callback2 != NULL) {
 6e0:	505c                	lw	a5,36(s0)
                I2C1->DATAR = 0x00;
            }
        } else {
            if (i2c_slave_state.position < i2c_slave_state.size1) {
                I2C1->DATAR = i2c_slave_state.registers1[i2c_slave_state.position];
                if (i2c_slave_state.read_callback1 != NULL) {
 6e2:	c391                	beqz	a5,6e6 <I2C1_EV_IRQHandler+0xc4>
                    i2c_slave_state.read_callback1(i2c_slave_state.position);
 6e4:	9782                	jalr	a5
                }
                i2c_slave_state.position++;
 6e6:	00244783          	lbu	a5,2(s0)
 6ea:	0785                	addi	a5,a5,1
 6ec:	00f40123          	sb	a5,2(s0)
                I2C1->DATAR = 0x00;
            }
        }
    }

    if (STAR1 & I2C_STAR1_STOPF) { // Stop event
 6f0:	88c1                	andi	s1,s1,16
 6f2:	cc85                	beqz	s1,72a <I2C1_EV_IRQHandler+0x108>
        I2C1->CTLR1 &= ~(I2C_CTLR1_STOP); // Clear stop
 6f4:	40005737          	lui	a4,0x40005
 6f8:	40075783          	lhu	a5,1024(a4) # 40005400 <__global_pointer$+0x20004c00>
 6fc:	07c2                	slli	a5,a5,0x10
 6fe:	83c1                	srli	a5,a5,0x10
 700:	dff7f793          	andi	a5,a5,-513
 704:	07c2                	slli	a5,a5,0x10
 706:	83c1                	srli	a5,a5,0x10
 708:	40f71023          	sh	a5,1024(a4)
        if (i2c_slave_state.address2matched) {
 70c:	92418793          	addi	a5,gp,-1756 # 20000124 <i2c_slave_state>
 710:	02a7c703          	lbu	a4,42(a5)
 714:	c74d                	beqz	a4,7be <I2C1_EV_IRQHandler+0x19c>
            if (i2c_slave_state.write_callback2 != NULL) {
 716:	5398                	lw	a4,32(a5)
                i2c_slave_state.write_callback2(i2c_slave_state.offset, i2c_slave_state.position - i2c_slave_state.offset);
            }
        } else {
            if (i2c_slave_state.write_callback1 != NULL) {
 718:	cb09                	beqz	a4,72a <I2C1_EV_IRQHandler+0x108>
                i2c_slave_state.write_callback1(i2c_slave_state.offset, i2c_slave_state.position - i2c_slave_state.offset);
 71a:	0017c503          	lbu	a0,1(a5)
 71e:	0027c583          	lbu	a1,2(a5)
 722:	8d89                	sub	a1,a1,a0
 724:	0ff5f593          	andi	a1,a1,255
 728:	9702                	jalr	a4
            }
        }
    }
}
 72a:	4472                	lw	s0,28(sp)
 72c:	50b2                	lw	ra,44(sp)
 72e:	52a2                	lw	t0,40(sp)
 730:	5312                	lw	t1,36(sp)
 732:	5382                	lw	t2,32(sp)
 734:	44e2                	lw	s1,24(sp)
 736:	4552                	lw	a0,20(sp)
 738:	45c2                	lw	a1,16(sp)
 73a:	4632                	lw	a2,12(sp)
 73c:	46a2                	lw	a3,8(sp)
 73e:	4712                	lw	a4,4(sp)
 740:	4782                	lw	a5,0(sp)
 742:	6145                	addi	sp,sp,48
 744:	30200073          	mret
            if (i2c_slave_state.address2matched) {
 748:	02a7c683          	lbu	a3,42(a5)
            i2c_slave_state.writing = true;
 74c:	4705                	li	a4,1
 74e:	02e784a3          	sb	a4,41(a5)
                if (i2c_slave_state.position < i2c_slave_state.size2 && !i2c_slave_state.read_only2) {
 752:	0027c703          	lbu	a4,2(a5)
            if (i2c_slave_state.address2matched) {
 756:	c695                	beqz	a3,782 <I2C1_EV_IRQHandler+0x160>
                if (i2c_slave_state.position < i2c_slave_state.size2 && !i2c_slave_state.read_only2) {
 758:	0107c683          	lbu	a3,16(a5)
 75c:	f4d774e3          	bgeu	a4,a3,6a4 <I2C1_EV_IRQHandler+0x82>
 760:	0287c683          	lbu	a3,40(a5)
 764:	f2a1                	bnez	a3,6a4 <I2C1_EV_IRQHandler+0x82>
                    i2c_slave_state.registers2[i2c_slave_state.position] = I2C1->DATAR;
 766:	400056b7          	lui	a3,0x40005
 76a:	4106d603          	lhu	a2,1040(a3) # 40005410 <__global_pointer$+0x20004c10>
 76e:	47d4                	lw	a3,12(a5)
                    i2c_slave_state.registers1[i2c_slave_state.position] = I2C1->DATAR;
 770:	96ba                	add	a3,a3,a4
 772:	0ff67613          	andi	a2,a2,255
 776:	00c68023          	sb	a2,0(a3)
                    i2c_slave_state.position++;
 77a:	0705                	addi	a4,a4,1
 77c:	00e78123          	sb	a4,2(a5)
 780:	b715                	j	6a4 <I2C1_EV_IRQHandler+0x82>
                if (i2c_slave_state.position < i2c_slave_state.size1 && !i2c_slave_state.read_only1) {
 782:	0087c683          	lbu	a3,8(a5)
 786:	f0d77fe3          	bgeu	a4,a3,6a4 <I2C1_EV_IRQHandler+0x82>
 78a:	01c7c683          	lbu	a3,28(a5)
 78e:	fa99                	bnez	a3,6a4 <I2C1_EV_IRQHandler+0x82>
                    i2c_slave_state.registers1[i2c_slave_state.position] = I2C1->DATAR;
 790:	400056b7          	lui	a3,0x40005
 794:	4106d603          	lhu	a2,1040(a3) # 40005410 <__global_pointer$+0x20004c10>
 798:	43d4                	lw	a3,4(a5)
 79a:	bfd9                	j	770 <I2C1_EV_IRQHandler+0x14e>
            if (i2c_slave_state.position < i2c_slave_state.size1) {
 79c:	00844703          	lbu	a4,8(s0)
 7a0:	00e57c63          	bgeu	a0,a4,7b8 <I2C1_EV_IRQHandler+0x196>
                I2C1->DATAR = i2c_slave_state.registers1[i2c_slave_state.position];
 7a4:	4058                	lw	a4,4(s0)
 7a6:	972a                	add	a4,a4,a0
 7a8:	00074703          	lbu	a4,0(a4)
 7ac:	0ff77713          	andi	a4,a4,255
 7b0:	00e79823          	sh	a4,16(a5)
                if (i2c_slave_state.read_callback1 != NULL) {
 7b4:	4c1c                	lw	a5,24(s0)
 7b6:	b735                	j	6e2 <I2C1_EV_IRQHandler+0xc0>
                I2C1->DATAR = 0x00;
 7b8:	00079823          	sh	zero,16(a5)
 7bc:	bf15                	j	6f0 <I2C1_EV_IRQHandler+0xce>
            if (i2c_slave_state.write_callback1 != NULL) {
 7be:	4bd8                	lw	a4,20(a5)
 7c0:	bfa1                	j	718 <I2C1_EV_IRQHandler+0xf6>

000007c2 <I2C1_ER_IRQHandler>:

void I2C1_ER_IRQHandler(void) __attribute__((interrupt));
void I2C1_ER_IRQHandler(void) {
 7c2:	1151                	addi	sp,sp,-12
 7c4:	c23a                	sw	a4,4(sp)
    uint16_t STAR1 = I2C1->STAR1;
 7c6:	40005737          	lui	a4,0x40005
void I2C1_ER_IRQHandler(void) {
 7ca:	c03e                	sw	a5,0(sp)
    uint16_t STAR1 = I2C1->STAR1;
 7cc:	41475783          	lhu	a5,1044(a4) # 40005414 <__global_pointer$+0x20004c14>
void I2C1_ER_IRQHandler(void) {
 7d0:	c436                	sw	a3,8(sp)
    uint16_t STAR1 = I2C1->STAR1;
 7d2:	01079693          	slli	a3,a5,0x10

    if (STAR1 & I2C_STAR1_BERR) { // Bus error
 7d6:	1007f793          	andi	a5,a5,256
    uint16_t STAR1 = I2C1->STAR1;
 7da:	82c1                	srli	a3,a3,0x10
    if (STAR1 & I2C_STAR1_BERR) { // Bus error
 7dc:	cf89                	beqz	a5,7f6 <I2C1_ER_IRQHandler+0x34>
        I2C1->STAR1 &= ~(I2C_STAR1_BERR); // Clear error
 7de:	41475783          	lhu	a5,1044(a4)
 7e2:	40070713          	addi	a4,a4,1024
 7e6:	07c2                	slli	a5,a5,0x10
 7e8:	83c1                	srli	a5,a5,0x10
 7ea:	eff7f793          	andi	a5,a5,-257
 7ee:	07c2                	slli	a5,a5,0x10
 7f0:	83c1                	srli	a5,a5,0x10
 7f2:	00f71a23          	sh	a5,20(a4)
    }

    if (STAR1 & I2C_STAR1_ARLO) { // Arbitration lost error
 7f6:	2006f793          	andi	a5,a3,512
 7fa:	cf89                	beqz	a5,814 <I2C1_ER_IRQHandler+0x52>
        I2C1->STAR1 &= ~(I2C_STAR1_ARLO); // Clear error
 7fc:	40005737          	lui	a4,0x40005
 800:	41475783          	lhu	a5,1044(a4) # 40005414 <__global_pointer$+0x20004c14>
 804:	07c2                	slli	a5,a5,0x10
 806:	83c1                	srli	a5,a5,0x10
 808:	dff7f793          	andi	a5,a5,-513
 80c:	07c2                	slli	a5,a5,0x10
 80e:	83c1                	srli	a5,a5,0x10
 810:	40f71a23          	sh	a5,1044(a4)
    }

    if (STAR1 & I2C_STAR1_AF) { // Acknowledge failure
 814:	4006f693          	andi	a3,a3,1024
 818:	ce89                	beqz	a3,832 <I2C1_ER_IRQHandler+0x70>
        I2C1->STAR1 &= ~(I2C_STAR1_AF); // Clear error
 81a:	40005737          	lui	a4,0x40005
 81e:	41475783          	lhu	a5,1044(a4) # 40005414 <__global_pointer$+0x20004c14>
 822:	07c2                	slli	a5,a5,0x10
 824:	83c1                	srli	a5,a5,0x10
 826:	bff7f793          	andi	a5,a5,-1025
 82a:	07c2                	slli	a5,a5,0x10
 82c:	83c1                	srli	a5,a5,0x10
 82e:	40f71a23          	sh	a5,1044(a4)
    }
}
 832:	46a2                	lw	a3,8(sp)
 834:	4712                	lw	a4,4(sp)
 836:	4782                	lw	a5,0(sp)
 838:	0131                	addi	sp,sp,12
 83a:	30200073          	mret
	...

Disassembly of section .data:

20000000 <pwm_max_duty>:
20000000:	00000030 00000000                       0.......

20000008 <ADC1_IRQHandler>:
{
20000008:	1121                	addi	sp,sp,-24
2000000a:	ca2a                	sw	a0,20(sp)
2000000c:	c82e                	sw	a1,16(sp)
2000000e:	c632                	sw	a2,12(sp)
20000010:	c436                	sw	a3,8(sp)
20000012:	c23a                	sw	a4,4(sp)
20000014:	c03e                	sw	a5,0(sp)
	ADC1->STATR = 0;
20000016:	400127b7          	lui	a5,0x40012
2000001a:	4007a023          	sw	zero,1024(a5) # 40012400 <__global_pointer$+0x20011c00>
2000001e:	40078713          	addi	a4,a5,1024
	int newadc = adcraw + (lastadc - (lastadc>>ADC_IIR));
20000022:	91018693          	addi	a3,gp,-1776 # 20000110 <lastadc>
	int adcraw = ADC1->RDATAR;
20000026:	4770                	lw	a2,76(a4)
	int newadc = adcraw + (lastadc - (lastadc>>ADC_IIR));
20000028:	4298                	lw	a4,0(a3)
	integral = ( integral > ((I_SAT_MAX)<<ADC_IIR) ) ? ((I_SAT_MAX)<<ADC_IIR) : integral;
2000002a:	6519                	lui	a0,0x6
	int newadc = adcraw + (lastadc - (lastadc>>ADC_IIR));
2000002c:	40275793          	srai	a5,a4,0x2
20000030:	40f707b3          	sub	a5,a4,a5
20000034:	97b2                	add	a5,a5,a2
	lastadc = newadc;
20000036:	c29c                	sw	a5,0(a3)
	int err = feedback_vdd - lastadc;
20000038:	9081a703          	lw	a4,-1784(gp) # 20000108 <feedback_vdd>
	int derivative = (err - lasterr);
2000003c:	91418613          	addi	a2,gp,-1772 # 20000114 <lasterr.2>
	int err = feedback_vdd - lastadc;
20000040:	8f1d                	sub	a4,a4,a5
	int derivative = (err - lasterr);
20000042:	420c                	lw	a1,0(a2)
	lasterr = err;
20000044:	c218                	sw	a4,0(a2)
	integral += err;
20000046:	90c1a783          	lw	a5,-1780(gp) # 2000010c <integral.1>
	int derivative = (err - lasterr);
2000004a:	40b705b3          	sub	a1,a4,a1
	integral = ( integral < ((I_SAT_MIN)<<ADC_IIR) ) ? ((I_SAT_MIN)<<ADC_IIR) : integral;
2000004e:	90818693          	addi	a3,gp,-1784 # 20000108 <feedback_vdd>
	integral += err;
20000052:	97ba                	add	a5,a5,a4
20000054:	90c18613          	addi	a2,gp,-1780 # 2000010c <integral.1>
	integral = ( integral > ((I_SAT_MAX)<<ADC_IIR) ) ? ((I_SAT_MAX)<<ADC_IIR) : integral;
20000058:	00f55363          	bge	a0,a5,2000005e <ADC1_IRQHandler+0x56>
2000005c:	6799                	lui	a5,0x6
	integral = ( integral < ((I_SAT_MIN)<<ADC_IIR) ) ? ((I_SAT_MIN)<<ADC_IIR) : integral;
2000005e:	7571                	lui	a0,0xffffc
20000060:	00a7d363          	bge	a5,a0,20000066 <ADC1_IRQHandler+0x5e>
20000064:	77f1                	lui	a5,0xffffc
20000066:	c21c                	sw	a5,0(a2)
		(integral >> ( ADC_IIR - (ERROR_I_TERM) )) +
20000068:	879d                	srai	a5,a5,0x7
		(err << ( (-ADC_IIR) + (ERROR_P_TERM) )) +
2000006a:	97ba                	add	a5,a5,a4
	plant = ( plant > pwm_max_duty ) ? pwm_max_duty : plant;
2000006c:	20000637          	lui	a2,0x20000
		(derivative >> ( (ADC_IIR) - (ERROR_D_TERM) ) );
20000070:	4035d713          	srai	a4,a1,0x3
	int plant = 
20000074:	97ba                	add	a5,a5,a4
	plant = ( plant > pwm_max_duty ) ? pwm_max_duty : plant;
20000076:	00062703          	lw	a4,0(a2) # 20000000 <pwm_max_duty>
2000007a:	00060613          	mv	a2,a2
2000007e:	00e7d363          	bge	a5,a4,20000084 <ADC1_IRQHandler+0x7c>
20000082:	873e                	mv	a4,a5
	plant = ( plant < 0 ) ? 0 : plant;
20000084:	87ba                	mv	a5,a4
20000086:	00075363          	bgez	a4,2000008c <ADC1_IRQHandler+0x84>
2000008a:	4781                	li	a5,0
	TIM1->CH2CVR = plant;
2000008c:	40013737          	lui	a4,0x40013
20000090:	c0070713          	addi	a4,a4,-1024 # 40012c00 <__global_pointer$+0x20012400>
20000094:	df1c                	sw	a5,56(a4)
	uint32_t vdd = lastrefvdd = ADC1->IDATAR1 + (lastrefvdd - (lastrefvdd>>VDD_IIR));
20000096:	91c18713          	addi	a4,gp,-1764 # 2000011c <lastrefvdd>
2000009a:	430c                	lw	a1,0(a4)
2000009c:	400127b7          	lui	a5,0x40012
200000a0:	40078793          	addi	a5,a5,1024 # 40012400 <__global_pointer$+0x20011c00>
200000a4:	5fc8                	lw	a0,60(a5)
200000a6:	4025d793          	srai	a5,a1,0x2
200000aa:	40f587b3          	sub	a5,a1,a5
200000ae:	97aa                	add	a5,a5,a0
		- (lastrefvdd>>(6+VDD_IIR))
200000b0:	4087d593          	srai	a1,a5,0x8
	uint32_t vdd = lastrefvdd = ADC1->IDATAR1 + (lastrefvdd - (lastrefvdd>>VDD_IIR));
200000b4:	c31c                	sw	a5,0(a4)
		  (lastrefvdd>>(2+VDD_IIR)) 
200000b6:	4047d713          	srai	a4,a5,0x4
		- (lastrefvdd>>(6+VDD_IIR))
200000ba:	8f0d                	sub	a4,a4,a1
		- (lastrefvdd>>(7+VDD_IIR));
200000bc:	4097d593          	srai	a1,a5,0x9
200000c0:	8f0d                	sub	a4,a4,a1
	pwm_max_duty = 
200000c2:	c218                	sw	a4,0(a2)
	uint32_t numerator = FastMultiply( vdd, target_feedback );
200000c4:	9201a603          	lw	a2,-1760(gp) # 20000120 <target_feedback>
	uint32_t ret = 0;
200000c8:	4701                	li	a4,0
		if( multiplicand & 1 )
200000ca:	00167593          	andi	a1,a2,1
200000ce:	c191                	beqz	a1,200000d2 <ADC1_IRQHandler+0xca>
			ret += mutliplicant;
200000d0:	973e                	add	a4,a4,a5
		multiplicand>>=1;
200000d2:	8205                	srli	a2,a2,0x1
		mutliplicant<<=1;
200000d4:	0786                	slli	a5,a5,0x1
	} while( multiplicand );
200000d6:	fa75                	bnez	a2,200000ca <ADC1_IRQHandler+0xc2>
		(numerator>>(7+VDD_IIR-ADC_IIR)) +
200000d8:	00775793          	srli	a5,a4,0x7
		(numerator>>(11+VDD_IIR-ADC_IIR));
200000dc:	832d                	srli	a4,a4,0xb
		(numerator>>(7+VDD_IIR-ADC_IIR)) +
200000de:	973e                	add	a4,a4,a5
	IWDG->CTLR = 0xAAAA;
200000e0:	67ad                	lui	a5,0xb
	feedback_vdd =
200000e2:	c298                	sw	a4,0(a3)
	IWDG->CTLR = 0xAAAA;
200000e4:	aaa78793          	addi	a5,a5,-1366 # aaaa <nixitest1.c.1638a390+0x8883>
200000e8:	40003737          	lui	a4,0x40003
200000ec:	c31c                	sw	a5,0(a4)
}
200000ee:	4552                	lw	a0,20(sp)
200000f0:	45c2                	lw	a1,16(sp)
200000f2:	4632                	lw	a2,12(sp)
200000f4:	46a2                	lw	a3,8(sp)
200000f6:	4712                	lw	a4,4(sp)
200000f8:	4782                	lw	a5,0(sp)
200000fa:	0161                	addi	sp,sp,24
200000fc:	30200073          	mret
